---
export interface CarouselImageItem {
	type?: 'image';
	src: string;
	alt: string;
}

export interface CarouselVideoItem {
	type: 'video';
	src: string;
	alt: string;
	poster?: string;
}

export type CarouselItem = CarouselImageItem | CarouselVideoItem;

export interface Props {
	images: Array<CarouselItem>;
	id: string;
}

const { images, id } = Astro.props;

const isVideo = (item: CarouselItem): item is CarouselVideoItem => item.type === 'video';
---

<div class="embla" data-carousel-id={id}>
	<div class="embla__viewport">
		<div class="embla__container">
			{images.map((item) => (
				<div class="embla__slide">
					{isVideo(item) ? (
						<video
							class="project-image project-video embla__slide-video"
							src={item.src}
							poster={item.poster}
							aria-label={item.alt}
							autoplay
							muted
							loop
							playsinline
							data-embla-video
						></video>
					) : (
						<img src={item.src} alt={item.alt} class="project-image" />
					)}
				</div>
			))}
		</div>
	</div>
	
	<div class="embla__dots">
		{images.map((_, index) => (
			<button 
				type="button" 
				class="embla__dot" 
				data-index={index}
				aria-label={`Go to slide ${index + 1}`}
			></button>
		))}
	</div>
</div>

<script>
	// Initialize all carousels on the page
	document.addEventListener('DOMContentLoaded', async () => {
		// Dynamic import for production compatibility
		const EmblaCarousel = (await import('embla-carousel')).default;
		const carousels = document.querySelectorAll('.embla');
		
		carousels.forEach((carousel) => {
			const viewport = carousel.querySelector<HTMLElement>('.embla__viewport');
			const dots = carousel.querySelectorAll<HTMLButtonElement>('.embla__dot');
			
			// Ensure we have a concrete HTMLElement for Embla
			if (!(viewport instanceof HTMLElement)) return;
			
			const embla = EmblaCarousel(viewport, {
				loop: true,
				align: 'center',
				watchDrag: (emblaApi, evt) => {
					// Allow pinch-zoom by disabling drag when multi-touch detected
					if (evt instanceof TouchEvent && evt.touches.length > 1) {
						return false;
					}
					return true;
				}
			});
			
			// Update dot states and play/pause videos in slides
			const updateDots = () => {
				const selectedIndex = embla.selectedScrollSnap();
				dots.forEach((dot, index) => {
					dot.classList.toggle('embla__dot--selected', index === selectedIndex);
				});
				// Pause all videos in this carousel, then play the selected slide's video
				const slides = carousel.querySelectorAll('.embla__slide');
				slides.forEach((slide, index) => {
					const video = slide.querySelector<HTMLVideoElement>('[data-embla-video]');
					if (video) {
						if (index === selectedIndex) {
							video.play().catch(() => {});
						} else {
							video.pause();
						}
					}
				});
			};
			
			// Initialize dots and video state
			updateDots();
			embla.on('select', updateDots);
			
			// Add click handlers to dots
			dots.forEach((dot, index) => {
				dot.addEventListener('click', (e) => {
					e.stopPropagation();
					embla.scrollTo(index);
				});
			});

			// Click on viewport/slide advances to next slide (only if not a drag)
			let pointerStart = { x: 0, y: 0 };
			viewport.addEventListener('pointerdown', (e) => {
				pointerStart = { x: e.clientX, y: e.clientY };
			});
			viewport.addEventListener('click', (e) => {
				// Ignore clicks that came from the dots (they have their own handler)
				if ((e.target as HTMLElement).closest('.embla__dots')) return;
				// Only advance if the pointer barely moved (real click, not drag end)
				const dx = e.clientX - pointerStart.x;
				const dy = e.clientY - pointerStart.y;
				if (dx * dx + dy * dy < 100) {
					embla.scrollNext();
				}
			});
		});
	});
</script>
